---
layout: post
title: "<垃圾回收的算法与实现>"
date: 2018-01-14 00:00:00 +0800
tags: [GC]
categories: [计算机, GC]
---


### [垃圾回收的算法与实现Q](https://book.douban.com/subject/26821357/)


#### CH1

* Q1. GC的评价标准是什么?
* Q2. GC中的基本概念有哪些?

#### CH2

* Q1. 什么是`标记清除`?伪代码如何?
* Q2. 标记清除的优缺点?





### [垃圾回收的算法与实现A]

#### CH1

* A1. 评价标准

    考虑到GC起到了对`对象new&free`的管理工作。同时可以考虑GC需要管理的是`Heap`空间。那么抛开GC的实现, 我们会关心如下内容:

    * GC的最大暂停时间: 这个在于`最大暂停时间`会STOP-THE-WORLD, 导致整个APP会暂停掉, 这个在高吞吐、低延迟的系统中会导致pct99较高.
    * Heap的使用效率: 好比GC复制算法的Heap使用效率就很低.
    * 吞吐量: heap_size/gc_cost, 这个我理解在于GC的工作效率
    * 访问局部性: 这个是系统的一些设定, 即将一些需要连续访问的对象, 组织在一起, 我理解这个是对缓存体系友好的.

* A2. 基本概念
    * 根、对象(头&域)、分块、分配、堆


#### CH2

* A1. 什么是标记清除?

    标记清除是两个部分的阶段。`标记阶段`将heap上的对象通过设置`ObjHeader.Flag=true`的方式进行记录, 打上true的对象, 含义为活动对象; `清除阶段`根据第一阶段中`ObjHeader.Flag=false`进行clean。

* A2. 伪代码?
	```
		def mark_sweep():
			mark()
			sweep()
	```

* A3. 标记清除的优缺点?
	* 优点
		* 算法简单, 易于实现
		* 可以与其他GC算法组合使用
	* 缺点
		* 碎片(我觉得所有GC算法都会有吧)
		* 分配速度(我觉得所有GC算法都会有吧)
		    * 核心应该是内存整理
		    * 多个空闲链表
		* 与fork, 写时复制(copy-on-write)不兼容
		    * 使用位图
* A4. 延迟清除一定可以提升效率么?

    不一定. 第一次Mark之后, 分为两个部分. 此时如果在可用部分进行了lazy_sweep, 则耗时会更长.