---
layout: post
title: "<垃圾回收的算法与实现>"
date: 2018-01-14 00:00:00 +0800
tags: [GC]
categories: [计算机, GC]
---


### [垃圾回收的算法与实现Q](https://book.douban.com/subject/26821357/)


#### CH1

* Q1. GC的评价标准是什么?
* Q2. GC中的基本概念有哪些?

#### CH2

* Q1. 什么是`标记清除`?伪代码如何?
* Q2. 标记清除的优缺点?


#### CH3

* Q1. 什么是`引用计数`?伪代码如何?
* Q2. 优点&缺点?
* Q3. 优化方向都有哪些?



### [垃圾回收的算法与实现A]

#### CH1

* A1. 评价标准

    考虑到GC起到了对`对象new&free`的管理工作。同时可以考虑GC需要管理的是`Heap`空间。那么抛开GC的实现, 我们会关心如下内容:

    * GC的最大暂停时间: 这个在于`最大暂停时间`会STOP-THE-WORLD, 导致整个APP会暂停掉, 这个在高吞吐、低延迟的系统中会导致pct99较高.
    * Heap的使用效率: 好比GC复制算法的Heap使用效率就很低.
    * 吞吐量: heap_size/gc_cost, 这个我理解在于GC的工作效率
    * 访问局部性: 这个是系统的一些设定, 即将一些需要连续访问的对象, 组织在一起, 我理解这个是对缓存体系友好的.

* A2. 基本概念
    * 根、对象(头&域)、分块、分配、堆


#### CH2

* A1. 什么是标记清除?

    标记清除是两个部分的阶段。`标记阶段`将heap上的对象通过设置`ObjHeader.Flag=true`的方式进行记录, 打上true的对象, 含义为活动对象; `清除阶段`根据第一阶段中`ObjHeader.Flag=false`进行clean。

* A2. 伪代码?
	```
		def mark_sweep():
			mark()
			sweep()
	```

* A3. 标记清除的优缺点?
	* 优点
		* 算法简单, 易于实现
		* 可以与其他GC算法组合使用
	* 缺点
		* 碎片(我觉得所有GC算法都会有吧)
		* 分配速度(我觉得所有GC算法都会有吧)
		    * 核心应该是内存整理
		    * 多个空闲链表
		* 与fork, 写时复制(copy-on-write)不兼容
		    * 使用位图
* A4. 优化方向有哪些?
	* 延迟清除

		* 一定不一定. 第一次Mark之后, 分为两个部分. 此时如果在可用部分进行了lazy_sweep, 则耗时会更长.



#### CH3

* A1. 什么是引用计数?

	在每个Obj中维护一个`计数域`, 当对象生成`newObject()`以及修改引用关系时`updatePtr(ptr, obj)`进行计数的增减. 计数为0后, 清理对象.

* A2. 伪代码?
	```
		def garbage_collection():
			pass

		def new_obj(size):
			obj = pickup_chunck(size, $free_list)
			if obj is None:
				aloocation_fail()
			else
				obj.ref_cnt = 1
				return obj

		def update_ptr(ptr, obj):
			inc_ref_cnt(obj)
			def_ref_cnt(*ptr)
			ptr = obj
	```

* A3. 引用计数的优缺点?
	* 优点:
		* 最大暂停时间很小(不需要沿着`根`进行遍历), 因为obj.ref_cnt==0时, 对象会被直接清除掉
		* 提升了内存使用率, heap上无垃圾对象(因为第一点)
	* 缺点:
		* 内存空间浪费的比较多, 因为要保存ref_cnt这个域
		* 处理事情变多(new_obj&update_ptr)都需要对ref_cnt进行修改
		* 无法解决循环引用

* A4. 优化方向?
	* 延迟引用计数
	* 引用计数+MARK-SWEEP
	* 1-bit-counting??!!(这个有疑问)
	* Partial-Mark-Sweep
		* black: 初始化颜色, 绝对不是垃圾
		* white: 绝对是垃圾
		* gray: 搜索完毕的对象
		* hatch: 可能是循环垃圾对象
		* 上述颜色的流转
			* def_ref_cnt: if obj.color != HATCH: obj.color = HATCH and Enqueue
			* scan_hatch_queue:
				* paint_gray, black|hatch -> gary
				* scan_gray, if obj.color == gray and obj.ref_cnt > 0 -> paint_black(obj) else white
				* paint_black
				* collect_white
		* 循环引用的产生
			* 产生循环引用
			* 删除从外部到循环引用的引用
		* 不足之处
			* 复杂度太高
			* 引用计数的优势(最大暂停时间), 荡然无存