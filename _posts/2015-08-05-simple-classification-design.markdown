---
layout: post
title:  "一个简单的商品分类系统的设计与实现"
date:   2015-08-06 21:04:30 +0800
categories: jekyll update
---

### 一个简单商品分类系统的设计与实现

分类系统是任何`门户`、`电商`、`团购`的基本需求，下面结合我工作中遇到的需求，来描述一个实现方式，并进行一些`定性定量`的分析。

本文由如下几个部分组成

* 需求分析
* 设计与实现
* 定性分析
* 总结


#### 需求分析

场景设定为，将商品进行分类而后供用户快速索引。

1. 对商品进行分类处理，包括`一级分类`、`二级分类`、`三级分类`等
2. 根据不同的类别，进行快速查询

#### 设计与实现

首先，先看一张图
![category_example](http://he-blog.oss-cn-beijing.aliyuncs.com/category_simple_impl.png)

首先，根据前文的需求描述，当我们选择某个`二级分类`的时候，会将所有的`三级分类`都筛选出来，也就是说

1. 点击`二级分类`的结果为 {男士皮鞋} U {跑步鞋}，其中跑步鞋既属于`运动鞋包`也同时属于`男鞋`这两个分类
2. 点击`三级分类`的结果直接取 {跑步鞋} 返回即可。

那么审视下这个设计，其实就是`检索`中粗浅的正排、倒排实现。

下面分别说下`正排`与`倒排`

正排，更类似于`key-value`的键值查询，例如图书馆中去找一本书，可以通过书名或者ISBN号进行精确查询。

倒排，可以说是按内容查询，[wiki上的例子](https://zh.wikipedia.org/wiki/%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95)，依旧在图书馆，我希望查询包含如下关键字的`算法`、`C语言`，则需要提前对所有书籍的内容分割，然后取`{算法} U {C语言}`当作返回值即可

OK，以上已经对需求及一些基本概念进行了普及，那么接下来，讨论一个初步的实现。

##### 一个简单的设计

`t_category`, 一级、二级类别关系大抵包含如下字段:

* category_id
* category_name
* parent_id

通过上述三个字段可以完整的描述出一级与二级类别的关系，因为一级、二级分类不存在耦合

`t_tag`, 三级分类包含字段如下:

* tag_id
* tag_name

`t_category_tag_relation`, 二级分类与三级分类的Relation:

* category_id
* tag_id

通过`两张元表`与`关系表`即可完整构建出完整的检索关系。

* 点击一级分类获取二级分类
* t_category query即可
* 点击二级分类获取三级分类
    * t_category_tag_relation query即可

----

`t_search`本质上一张`倒排表`，字段为

* tag_id
* item_id

此设计可以满足的检索要求如下

* 点击二级分类，获取所有二级分类下的商品
    * t_category_tag_relation -> tag_id集合
    * t_search -> item_id集合
    
* 点击三级分类，获取所有三级分类下的商品
    * t_search -> item_id集合
    
TODO: 此处写的还是有些乱，先mark下思绪，后续再整理吧~~包括利用数据库做这个事情与solr这种引擎的差异

----

还有一点需要提及，当进行`检索`操作时，由二级分类获取到三级分类的id集合，此时，可以通过`thread-pool`，并行去获取每个三级分类id下的item_id集合

之后在进行求交操作。

### 定性分析

下面做一个简单的性能分析，假设有200w的物品量，每个`item_id`为`long类型(64bit)`，保证连续的情况下共占用空间`16M`，然后如果我们三级分类`100个`，那么共占用内存`1600M`，最差的时间复杂度为`O(N * M)`

下面总结下估算的结果

背景：size: 200w 每个大小: 8byte

* 元数据: 16M
* 集合数量: 100
* 总计空间: 100 * 16 = 1600M
* 最差求交的复杂度: O(N * M)`假设set结构通过hashtable实现，那么判定存在就是O(1)，所以总复杂度为O(N * M)`

对于最后的时间复杂度，假设机器的计算量为1000w/s，那么当100个200w的集合就是O(100 * 200 / 1000) = 20s

这个是串行计算的一个下界，还可以利用，归并的方式进行优化。


### 总结

基于以上的设计，实现了对分类的基础检索需求。

接下来的工作在于

1. 评估数据库实现的性能瓶颈
2. 比较与solr引擎的异同
3. 细化优化设计方案
4. 并行计算的优化问题
